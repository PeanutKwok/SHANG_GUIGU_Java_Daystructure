public class DataType05
{
  public static void main(String[] args){

      long x = 100L；
      //100L是long类型字面值
      //x是long类型变量
      //不存在类型转换，直接赋值

      //x变量是long类型，8个字节
      //y变量是int类型，4个字节
      int y = x;
      //编译报错，编译不通过，大容量不能直接赋值给小容量
      //强制类型转换需要加"强制类型转换符"
      //加上强制类型转换符之后编译通过了
      //但是运行阶段可能损失精度
      //所以强制类型转换谨慎使用，因为可能严重损失精度

  //强转原理
  //原始数据00000000 00000000 00000000 00000000
  //        00000000 00000000 00000000 01100100
  //强转之后 00000000 00000000 00000000 01100100
  //将左边的二进制删除[所有的数据强转的时候都是这样完成的]

      int y = (int)x;
      System.out.println(y);


      //原始数据00000000 00000000 00000000 00000000
      //       10000000 00000000 00000000 00000000

      //强转之后10000000 00000000 00000000 00000000
      //计算机内存储数据使用补码的形式
      //将以上补码转换到源码就是最终的结果
      long k = 2147483648L;
      int e = (int)k;
      System.out.println(e);//损失精度严重，结果是负数
      //[-2147483648]

      byte b = 50;//可以
      //依据目前所学习知识
      //理由50是int类型字面值，b是byte类型变量
      //显然是大容量转换成小容量
      //大容量转换小容量需要添加强制类型转换符号
      //没有添加强制转换符号，编译报错

      //但是实际编译没有报错
      //说明在java语言中，当一个整数型字面值
      //没有超过byte类型取值范围的话
      //该字面值可以直接赋值给byte类型的变量
      byte b = 50;
      byte c = 127;
      byte b1 = 128;//不行
//原始数据： 00000000 00000000 00000000 10000000
//强转之后:  10000000
//[这是存储在计算机内部的，是一个补码，源码是什么]
//正整数补码是其二进制表示，与源码相同
//负数补码，将其对应正数二进制表示所有位取反，加1
//包括符号位，0变1，1变0.最后加1

//补码：1000 0000一个数在计算机中: 求实际数值
//减1   0111 1111
//取反  1000 0000得到原码
//

//计算机表示二进制，三种表示形式:
//正数的补码 和原码相同
//负数的补码


byte m = (byte)198;
//198默认为int对应二进制
//00000000 00000000 00000000  1100 0110
//除符号位按位取反 1011 1001
//加一 1011 1010 对应10进制 -58
//负数补码有2种求法，补码的补码是原码
//负数补码可以除符号位，按位取反再加1

short s = 32767;//通过
short s = 32768;//报错 超出short取值范围

char cc =65535;
char cc1=65536;
//当一个整数字面值梅雨超出byte,short,char的取值范围
//这个字面值可以直接赋值给byte,short,char类型的变量
//这种机制SUN允许，目的是为了方便程序员的编程。



  关于浮点型数据类型
    float 单精度[4字节]
    double 双精度[8字节]

    double精度太低，相对不适合做财务软件
    所以在SUN在基础SE类库当中
    为程序员准备了精确度更好的数据类型，只不过是一种引用数据类型，不是基本数据类型，它是:java.math.BigDecimal

    其实java程序中SUN提供了一套庞大的类库，java程序员是基于这套类库来进行开发的。
      *SE类库字节码
      :C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar

      *SE类库源码:
      C:\Program Files\Java\jdk1.8.0_181\src.zip

      例如String.java 和String.class
      (String[] args)中的String使用的是String.class字节码文件

      java语言当中，所有的浮点型字面值 例如【3.0】
      默认被当作double来处理

    /*  注意:
        *double和float在计算机内部二进制存储的时候都是近似值。
        例如2.3333333333333
    */






      要想该字面值当作float类型来处理，需要在字面值后面添加F/f

      double d = 3.0; //可以
      float f = 5.1;
      //5.1是double类型的字面值
      //f是float字面值
      //小容量转换大容量，需要强制类型转换

      float f = 5.1f;//可以


布尔型数据类型（Boolean)

    *在java语言当中boolean只有2个值，true,false

    *在底层存储的时候boolean类型只占用1个字节
  因为存储的时候false底层是0,true底层是1

    *布尔类型在实际开发中非常重要，经常使用在逻辑运算和条件控制语句当中。
public class DataType07
{
  public static void main(String[] args){
      boolean flag = 1;//编译错误，不兼容的类型

      boolean loginSucess = true;

      if(loginSucess){
        System.out.println("恭喜你，登录成功");
      }
      else
        System.out.println("对不起，用户名不存在");

  }
}


--------------------------------------------------
    关于基本数据类型之间的互相转换:转换规则
      1、八种数据类型当中除布尔类型之外剩下的7中数据类型都可以互相转换。
      2、小容量向大容量转换，成为自动类型转换，容量从小到大排序:
      byte < short=char < int < long < float <double

    *注意：
      任何浮点类型不管占用多少个字节，都比整数型容量大。
      char和short可表示的种类数量相同，但是char可以取更大的正整数。

      3.大容量转换成小容量，需要强制类型转换符号，才能编译通过，但是在运行阶段可能会损失精度，所以需要谨慎使用。

      4.当正数字面值没有超过byte,short,char的取值范围，可以直接赋值给byte,short,char类型的变量

      5.byte、short、char混合运算，各自先转换成int 类型再做运算。

      6.多种数据类型混合运算，先转换成容量最大的数据类型再进行运算。





      byte a = 1000;
      //错误，超出了byte取值范围。-128~127

      byte a = 20;
      //可以赋值，没有超出byte范围，但变量不能重名。
      short b = 1000;
      //short取值范围 -32768~32767
      //在取值范围之内,进行了类型转换

      int c = 1000;
      //正确，字面值类型和int类型一致，

      long d = c;
      //正确，可以自动转换。小容量转换为大容量。



      int e = (int)d;
      //大容量转换为小容量，
      //需要强制类型转换，转换后1000，没超过int存储范围

      int f = 10/3;
      //除法得3

      double dd = 10/3;
      //10/3结果为int类型3，再进行自动类型转换为3.0

      dd = 10.0/3;
      //输出结果为3.33333333333333 分母3被强制类型转换为3.0

      long g = 10;

      int h = g/3; //不行

      int h = int(g/3);//可以
      long h = g/3;//ok
      byte h = (byte)(int)g/3;
      //javac只负责语法检查，不进行计算 加括号就对了。运算符优先级的问题。
      //g进行数值转换后，再除3，3为int类型，数值报错。
      byte b = 3;//可以编译通过，3没有超出byte类型取值范围

      int i = 10;
      byte b = i/3;
      //编译器报错，编译器只检查语法，不进行运算。

      byte h = (byte)g/3;
      //同理 3为int类型

      short i = 10;
       //混合运算，先各自转换为int类型在运算。报错。
      byte j = 5;
      short k = i + j;//编译只检查语法，不算结果，报错。
      short k = 15;//可以

      short k = （i + j）;//可以

      int k = i + j;//可以

      char l ='a';
      System.out.println(l);//输出a
      System.out.println((byte)l);//97

      int m = l + 100;
      System.out.println(l);//输出197


    //44课程






























  }
}
